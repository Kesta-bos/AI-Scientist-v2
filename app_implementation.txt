# AI Scientist v2 Gradio Demo Implementation Log

## Setup & Structure (app.py)
- Created `app.py`.
- Added project root to `sys.path` to allow importing `ai_scientist` modules.
- Imported necessary `gradio`, `os`, `sys`, `json`, `time`, `traceback`, `datetime`, `shutil`, `re`.
- Imported placeholder functions/modules from `ai_scientist` (will refine imports later).
- Added helper functions: `get_timestamp`, `format_log`.
- Created basic Gradio UI structure using `gr.Blocks` and `gr.Tabs`.
  - Tab 1: Input (Textbox, Dropdown, Button, Status Textbox).
  - Tab 2: Hypothesis (Log Textbox, Accordion for SemScholar, Final JSON). Increased log lines.
  - Tab 3: Experimentation (Stage Markdown, Log Textbox, Accordion for Plots/Gallery, Accordion for Best Node JSON).
  - Tab 4: Reporting (Accordions for Citations/Reflection/Compilation Logs, LaTeX Code, PDF File output).
- Defined the main orchestration function `run_ai_scientist_pipeline` as a generator.
- Connected the "Start" button (`start_button.click`) to `run_ai_scientist_pipeline`.
  - Specified all potentially updatable UI components in the `outputs` list.
  - Enabled Gradio's progress tracking (`show_progress="full"`).
- Added basic API key check on startup.
- Launched the demo using `demo.launch(debug=True)`.

## Phase 1: Ideation Integration (Actual Function Call)
- **Replaced** the simulation block for Phase 1.
- Imported `StringIO`, `contextlib`, `create_client`, `generate_temp_free_idea`.
- Added `parse_ideation_logs` helper function to separate general print logs from Semantic Scholar interactions based on patterns in stdout.
- In `run_ai_scientist_pipeline`:
  - Created `base_run_dir` using timestamp and part of the user prompt.
  - Defined `idea_json_path` within `base_run_dir`.
  - Set `max_generations=1` and `num_reflections=2` for faster demo execution.
  - Selected `ideation_model` (e.g., "gpt-4o-mini-2024-07-18").
  - Created the LLM client using `create_client`.
  - Used `contextlib.redirect_stdout` and `StringIO` to capture print output from `generate_temp_free_idea`.
  - Called `generate_temp_free_idea` with `reload_ideas=False`.
  - Parsed the captured stdout using `parse_ideation_logs`.
  - Yielded the parsed general logs to `ideation_log_textbox` and Semantic Scholar logs to `ideation_sem_scholar_textbox`.
  - Checked if ideas were generated. If yes, selected the first idea (`final_idea`) and yielded it to `ideation_final_json`.
  - If no ideas were generated or an exception occurred, yielded error messages and stopped the pipeline. Added specific check for `ImportError` related to `semantic_scholar`.
- **Note:** Capturing intermediate states beyond stdout parsing would require modifying `generate_temp_free_idea`.

## Phase 2: Experimentation Integration (Simulation - Unchanged)
- Kept the simulation logic for Phase 2.
- Added `try-except` blocks around PIL imports/usage for dummy plot generation to handle cases where PIL might not be installed, preventing crashes.
- **TODO:** Replace simulation with actual call to `perform_experiments_bfts`.

## Phase 3: Reporting Integration (Simulation - Minor Update)
- Kept the simulation logic for Phase 3.
- Updated the simulated LaTeX generation to use the actual `final_idea` dictionary (if generated successfully in Phase 1) to populate the title, hypothesis, and abstract, making the simulated output slightly more relevant.
- Updated `\graphicspath{{./}}` in simulated LaTeX for local compilation context. Changed bib filename to `references.bib`.
- Used `os.path.basename` for the plot path in LaTeX to avoid issues with absolute paths.
- **TODO:** Replace simulation with actual calls to `gather_citations`, `perform_icbinb_writeup`, `compile_latex`.

## Next Steps:
1.  **Test** the integrated Ideation phase thoroughly with different prompts and API keys set. Debug any issues with log capture or function calls.
2.  Begin integration of the **Experimentation phase** (`perform_experiments_bfts`). This will require the most significant work to adapt the existing tree search code to yield incremental updates suitable for Gradio. Decide on the level of detail to yield (every node? stage summaries?). Address local code execution safety (maybe add a confirmation step or run in a restricted environment if possible).
3.  Integrate the Reporting phase.